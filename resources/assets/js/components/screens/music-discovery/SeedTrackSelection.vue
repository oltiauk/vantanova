<template>
  <div class="seed-selection mb-8">
    <!-- Welcome Message with Last.fm Logo -->
    <div v-if="!selectedTrack && searchResults.length === 0 && !searchQuery.trim() && !isSearching" class="">
      <div class="max-w-4xl mx-auto">
        <div class="flex justify-center items-center py-4">
          <div class="text-center ml-6">
            <h3 class="text-lg font-bold text-white mb-2">Search for a Seed Track</h3>
            <p class="text-k-text-secondary">
              Search for a seed track to find related tracks
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Search Container -->
    <div class="search-container mb-6">
      <div class="rounded-lg p-4">
        <div class="max-w-4xl mx-auto">
          <div ref="searchContainer" class="relative">
            <!-- Search Icon -->
            <div class="absolute inset-y-0 left-0 flex items-center pointer-events-none z-20 pl-4">
              <Icon :icon="faSearch" class="w-5 h-5 text-white/40" />
            </div>

            <input
              v-model="searchQuery"
              type="text"
              class="w-full py-3 pl-12 pr-12 bg-white/10 rounded-lg focus:outline-none text-white text-lg search-input"
              placeholder="Search for a track"
              @input="onSearchInput"
            >

            <!-- Loading Animation -->
            <div
              v-if="isSearching && searchQuery.trim()"
              class="absolute z-50 w-full border border-k-border rounded-lg mt-1 shadow-xl"
              style="background-color: #302f30;"
            >
              <div class="flex items-center justify-center py-8">
                <div class="flex items-center gap-3">
                  <div class="animate-spin rounded-full h-6 w-6 border-2 border-k-accent border-t-transparent" />
                  <span class="text-k-text-secondary">Searching for tracks...</span>
                </div>
              </div>
            </div>

            <!-- Search Dropdown -->
            <div
              v-if="searchResults.length > 0 && !isSearching"
              class="absolute z-50 w-full border border-k-border rounded-lg mt-1 shadow-xl"
              style="background-color: #302f30;"
            >
              <div class="max-h-80 rounded-lg overflow-hidden overflow-y-auto">
                <div v-for="track in filteredSearchResults.slice(0, 10)" :key="`suggestion-${track.id}`">
                  <div
                    class="flex items-center justify-between px-4 py-3 hover:bg-k-bg-tertiary cursor-pointer transition-colors group border-b border-k-border/30 last:border-b-0"
                    :class="{
                      'bg-k-accent/10': selectedTrack && selectedTrack.id === track.id,
                    }"
                    @click="selectSeedTrack(track)"
                  >
                    <!-- Track Info -->
                    <div class="flex-1 min-w-0">
                      <div class="font-medium text-k-text-primary group-hover:text-k-accent transition-colors truncate">
                        {{ formatArtists(track) }} - {{ track.name }}
                      </div>
                    </div>

                    <!-- Duration Badge -->
                    <div class="bg-k-bg-primary/30 px-2 py-1 rounded text-k-text-tertiary text-xs font-mono ml-3 flex-shrink-0">
                      {{ formatDuration(track.duration_ms) }}
                    </div>
                  </div>
                </div>

                <div v-if="filteredSearchResults.length > 10" class="px-4 py-3 text-center text-k-text-tertiary text-sm border-t border-k-border bg-k-bg-tertiary/20">
                  <Icon :icon="faMusic" class="mr-1 opacity-50" />
                  {{ filteredSearchResults.length - 10 }} more tracks found
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Selected Seed Track Display - Compact -->
   
    </div> <div v-if="selectedTrack" class="selected-seed mb-4 relative z-20">
      <div class="max-w-4xl mx-auto">
        <div class="text-sm font-medium mb-2">Seed Track:</div>
        <div class="bg-k-bg-secondary/50 border border-k-border rounded-lg px-3 py-2">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-2 flex-1 min-w-0">
              <Icon :icon="faCheck" class="w-4 h-4 text-k-accent flex-shrink-0" />
              <span class="text-k-text-primary font-medium truncate">{{ formatArtists(selectedTrack) }} - {{ selectedTrack.name }}</span>
            </div>
            <button
              class="p-1 hover:bg-red-600/20 text-k-text-tertiary hover:text-red-400 rounded transition-colors flex-shrink-0 ml-2"
              title="Clear seed track"
              @click="clearSeedTrack"
            >
              <Icon :icon="faTimes" class="w-4 h-4" />
            </button>
          </div>
        </div>
      </div>

    <!-- Error State -->
    <div v-if="searchError" class="bg-red-500/20 border border-red-500/40 rounded-lg p-4 max-w-2xl mx-auto">
      <div class="flex items-start gap-3">
        <Icon :icon="faExclamationTriangle" class="text-red-400 mt-0.5" />
        <div>
          <h4 class="font-medium text-red-200 mb-1">Search Error</h4>
          <p class="text-red-200">{{ searchError }}</p>
        </div>
        <button
          class="ml-auto text-red-400 hover:text-red-300"
          @click="searchError = ''"
        >
          <Icon :icon="faTimes" class="w-4 h-4" />
        </button>
      </div>
    </div>

    <!-- Instructions -->
    <!-- <div v-if="!selectedTrack && searchResults.length === 0 && !searchQuery.trim() && !isSearching" class="text-center py-12">
      <h3 class="text-lg font-medium text-white mb-4">Find Your Seed Track</h3>
      <p class="text-white/60 text-md mb-6">
        Search for a song to use as the starting point for music discovery
      </p>
      <p class="text-white/40 text-sm">
        The algorithm will find similar tracks based on your selected parameters
      </p>
    </div> -->
  </div>
</template>

<script setup lang="ts">
import { faBan, faCheck, faExclamationTriangle, faHeart, faMusic, faPlay, faRandom, faSearch, faTimes, faUserMinus, faUserPlus } from '@fortawesome/free-solid-svg-icons'
import { computed, onMounted, onUnmounted, ref, watch } from 'vue'
import { http } from '@/services/http'
import { useBlacklistFiltering } from '@/composables/useBlacklistFiltering'

interface Track {
  id: string
  name: string
  artist: string
  album: string
  duration_ms?: number
  external_url?: string
  preview_url?: string
  image?: string
  uri?: string
  artists?: Array<{
    id: string
    name: string
  }>
}

// Props
interface Props {
  selectedTrack?: Track | null
  hasRecommendations?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  selectedTrack: null,
  hasRecommendations: false,
})

// Emits
const emit = defineEmits<{
  'update:selectedTrack': [track: Track | null]
  'track-selected': [track: Track]
  'related-tracks': [track: Track]
  'search-results-changed': [hasResults: boolean]
  'clear-recommendations': []
}>()

// State
const searchQuery = ref('')
const searchResults = ref<Track[]>([])
const searchError = ref('')
const currentPage = ref(1)
const isSearching = ref(false)
const expandedTrackId = ref<string | null>(null)
const searchContainer = ref<HTMLElement | null>(null)
let searchTimeout: NodeJS.Timeout | null = null

// Music preferences state
const savedTracks = ref<Set<string>>(new Set())
const blacklistedTracks = ref<Set<string>>(new Set())
const savedArtists = ref<Set<string>>(new Set())
const blacklistedArtists = ref<Set<string>>(new Set())
const processingTrack = ref<string | null>(null)

// Initialize blacklist filtering composable
const {
  isTrackBlacklisted,
  isArtistBlacklisted,
  isTrackOrArtistBlacklisted,
  loadBlacklistedItems,
} = useBlacklistFiltering()

// Computed - For seed track selection, filter out blacklisted TRACKS but allow blacklisted ARTISTS
// This allows users to select tracks by blacklisted artists as seed tracks
// but prevents blacklisted individual tracks from appearing
const filteredSearchResults = computed(() => {
  return searchResults.value.filter(track => {
    // Basic validation
    if (!track || !track.name || !track.artist) {
      return false
    }

    // Filter out blacklisted tracks (but allow tracks by blacklisted artists)
    if (isTrackBlacklisted(track)) {
      return false
    }

    return true
  })
})

const displayedTracks = computed(() => {
  const start = (currentPage.value - 1) * 20
  const end = start + 20
  return filteredSearchResults.value.slice(start, end)
})

// Helper functions
const getTrackKey = (track: Track): string => {
  return `${track.artist}-${track.name}`.toLowerCase().replace(/[^a-z0-9]/g, '-')
}

// Local helper functions for saved tracks/artists (separate from global blacklist)
const isTrackSaved = (track: Track): boolean => {
  return savedTracks.value.has(getTrackKey(track))
}

const isArtistSaved = (track: Track): boolean => {
  return savedArtists.value.has(track.artist.toLowerCase())
}

// Note: Using global blacklist functions from composable instead of local ones

const formatDuration = (ms?: number): string => {
  if (!ms) {
    return '0:00'
  }
  const minutes = Math.floor(ms / 60000)
  const seconds = Math.floor((ms % 60000) / 1000)
  return `${minutes}:${seconds.toString().padStart(2, '0')}`
}

const formatArtists = (track: Track): string => {
  // If track has multiple artists array, use that; otherwise fall back to single artist string
  if (track.artists && track.artists.length > 0) {
    return track.artists.map(artist => artist.name).join(', ')
  }
  return track.artist
}

// Auto-search functionality with debouncing
const onSearchInput = () => {
  // Clear existing timeout
  if (searchTimeout) {
    clearTimeout(searchTimeout)
  }

  // Clear results immediately if query is empty
  if (!searchQuery.value.trim()) {
    searchResults.value = []
    searchError.value = ''
    return
  }

  // Search works normally - recommendations will be hidden when search results show

  // Set new timeout for search
  searchTimeout = setTimeout(() => {
    searchTracks()
  }, 500) // Wait 500ms after user stops typing
}

// Search functionality
const searchTracks = async () => {
  if (!searchQuery.value.trim()) {
    return
  }

  // console.log('🔍 [FRONTEND] Starting search for:', searchQuery.value.trim())

  isSearching.value = true
  searchError.value = ''
  searchResults.value = []
  currentPage.value = 1

  try {
    // console.log('🔍 [FRONTEND] Making API call to music-discovery/search-seed')

    // Use the updated search-seed endpoint with Spotify fallback
    const response = await http.post('music-discovery/search-seed', {
      query: searchQuery.value.trim(),
      limit: 100,
    })

    // console.log('🔍 [FRONTEND] API Response received:', {
    //   success: response.success,
    //   dataLength: response.data?.length,
    //   error: response.error,
    // })

    if (response.success && response.data && Array.isArray(response.data)) {
      searchResults.value = response.data
      // console.log(`🔍 [FRONTEND] Found ${response.data.length} tracks from search`)
      // console.log('🔍 [FRONTEND] Sample track data:', response.data[0]) // Debug the structure
      // console.log('🔍 [FRONTEND] All tracks:', response.data.map(t => `${t.artist} - ${t.name}`))
    } else {
      throw new Error(response.error || 'Invalid response format from backend')
    }
  } catch (err: any) {
    // console.error('🔍 [FRONTEND] Search failed:', err)
    searchError.value = err.message || 'Failed to search tracks. Please try again.'
    searchResults.value = []
  } finally {
    isSearching.value = false
  }
}

// Seed track management
const selectSeedTrack = (track: Track) => {
  // Clear previous recommendations when selecting a new seed track
  emit('clear-recommendations')
  emit('update:selectedTrack', track)
  emit('track-selected', track)
  // Clear search results after selection
  searchResults.value = []
  searchQuery.value = ''
  // Always get related tracks for the newly selected seed track
  getRelatedTracks(track)
}

const clearSeedTrack = () => {
  emit('update:selectedTrack', null)
  // Clear search results to return to initial state
  searchResults.value = []
  searchQuery.value = ''
  // Emit event to clear recommendations
  emit('clear-recommendations')
}

const getRelatedTracks = (track: Track) => {
  // Clear search results when getting related tracks to prevent overlay
  searchResults.value = []
  searchQuery.value = ''

  // Just emit the related tracks request without setting as seed track
  // (the track should already be set as seed track if called from selectSeedTrack)
  emit('related-tracks', track)
}

// Music preferences
const saveTrack = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artist = track.artist
    const title = track.name

    if (isTrackSaved(track)) {
      // Remove from saved (using DELETE request)
      const response = await http.delete('music-preferences/saved-track', {
        data: {
          isrc: track.id,
          track_name: title,
          artist_name: artist,
        },
      })

      if (response.success) {
        savedTracks.value.delete(trackKey)
        // console.log('Track unsaved successfully')
      } else {
        throw new Error(response.error || 'Failed to unsave track')
      }
    } else {
      // Save track
      const response = await http.post('music-preferences/save-track', {
        isrc: track.id,
        track_name: title,
        artist_name: artist,
        duration: Math.floor((track.duration_ms || 0) / 1000),
        track_count: 1,
        is_single_track: true
      })

      if (response.success) {
        savedTracks.value.add(trackKey)
        // console.log('Track saved successfully')
      } else {
        throw new Error(response.error || 'Failed to save track')
      }
    }
  } catch (error: any) {
    // console.error('Failed to save track:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to save tracks'
    } else {
      searchError.value = `Failed to save track: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}

const toggleBlacklistTrack = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artist = track.artist
    const title = track.name

    if (isTrackBlacklisted(track)) {
      // Unblock track
      const response = await http.delete('music-preferences/blacklist-track', {
        data: {
          isrc: track.id,
          track_name: title,
          artist_name: artist,
        },
      })

      if (response.success) {
        blacklistedTracks.value.delete(trackKey)
        // console.log('Track unblocked successfully')
      } else {
        throw new Error(response.error || 'Failed to unblock track')
      }
    } else {
      // Block track
      const response = await http.post('music-preferences/blacklist-track', {
        isrc: track.id,
        track_name: title,
        artist_name: artist,
      })

      if (response.success) {
        blacklistedTracks.value.add(trackKey)
        // console.log('Track blacklisted successfully')
      } else {
        throw new Error(response.error || 'Failed to blacklist track')
      }
    }
  } catch (error: any) {
    // console.error('Failed to toggle blacklist:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to manage track preferences'
    } else {
      searchError.value = `Failed to toggle blacklist: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}

// Artist preferences
const saveArtist = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artistName = track.artist
    const artistKey = artistName.toLowerCase()

    if (isArtistSaved(track)) {
      // Remove from saved artists
      const response = await http.delete('music-preferences/saved-artist', {
        data: {
          spotify_artist_id: track.id, // Use track ID as fallback if no artist ID
          artist_name: artistName,
        },
      })

      if (response.success) {
        savedArtists.value.delete(artistKey)
        // console.log('Artist unsaved successfully')
      } else {
        throw new Error(response.error || 'Failed to unsave artist')
      }
    } else {
      // Save artist
      const response = await http.post('music-preferences/save-artist', {
        spotify_artist_id: track.id, // Use track ID as fallback if no artist ID
        artist_name: artistName,
      })

      if (response.success) {
        savedArtists.value.add(artistKey)
        // console.log('Artist saved successfully')
      } else {
        throw new Error(response.error || 'Failed to save artist')
      }
    }
  } catch (error: any) {
    // console.error('Failed to save artist:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to save artists'
    } else {
      searchError.value = `Failed to save artist: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}

const blacklistArtist = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artistName = track.artist
    const artistKey = artistName.toLowerCase()

    if (isArtistBlacklisted(track.artist)) {
      // Remove from blacklisted artists
      const response = await http.delete('music-preferences/blacklist-artist', {
        data: {
          spotify_artist_id: track.id, // Use track ID as fallback if no artist ID
          artist_name: artistName,
        },
      })

      if (response.success) {
        blacklistedArtists.value.delete(artistKey)
        // console.log('Artist unblacklisted successfully')
      } else {
        throw new Error(response.error || 'Failed to unblacklist artist')
      }
    } else {
      // Blacklist artist
      const response = await http.post('music-preferences/blacklist-artist', {
        spotify_artist_id: track.id, // Use track ID as fallback if no artist ID
        artist_name: artistName,
      })

      if (response.success) {
        blacklistedArtists.value.add(artistKey)
        // console.log('Artist blacklisted successfully')
      } else {
        throw new Error(response.error || 'Failed to blacklist artist')
      }
    }
  } catch (error: any) {
    // console.error('Failed to blacklist artist:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to manage artist preferences'
    } else {
      searchError.value = `Failed to blacklist artist: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}

// Pagination
const nextPage = () => {
  if (currentPage.value * 20 < filteredSearchResults.value.length) {
    currentPage.value++
  }
}

const previousPage = () => {
  if (currentPage.value > 1) {
    currentPage.value--
  }
}

// Watch search results and emit changes to parent
watch(searchResults, newResults => {
  emit('search-results-changed', newResults.length > 0)
})

// Watch for recommendations to clear search results and prevent overlay
watch(() => props.hasRecommendations, (hasRecommendations, wasRecommendations) => {
  // Only clear when recommendations first appear (transition from false to true)
  if (hasRecommendations && !wasRecommendations) {
    // Clear search results when recommendations first appear to prevent overlay
    searchResults.value = []
    searchQuery.value = ''
  }
})

// Click outside handler to close dropdown
const handleClickOutside = (event: MouseEvent) => {
  if (searchContainer.value && !searchContainer.value.contains(event.target as Node)) {
    searchResults.value = []
  }
}

// Load saved preferences on mount
onMounted(async () => {
  await loadUserPreferences()
  document.addEventListener('click', handleClickOutside)
})

// Clean up event listener
onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside)
})

// Load user's saved tracks and blacklisted items
const loadUserPreferences = async () => {
  try {
    // Load global blacklisted items (tracks + artists)
    await loadBlacklistedItems()

    // Load saved tracks (local to this component)
    const savedTracksResponse = await http.get('music-preferences/saved-tracks')
    if (savedTracksResponse.success && savedTracksResponse.data) {
      savedTracksResponse.data.forEach((track: any) => {
        const trackKey = `${track.artist_name}-${track.track_name}`.toLowerCase().replace(/[^a-z0-9]/g, '-')
        savedTracks.value.add(trackKey)
      })
      // console.log(`Loaded ${savedTracks.value.size} saved tracks`)
    }

    // Load saved artists (local to this component)
    const savedArtistsResponse = await http.get('music-preferences/saved-artists')
    if (savedArtistsResponse.success && savedArtistsResponse.data) {
      savedArtistsResponse.data.forEach((artist: any) => {
        savedArtists.value.add(artist.artist_name.toLowerCase())
      })
      // console.log(`Loaded ${savedArtists.value.size} saved artists`)
    }
  } catch (error) {
    //  console.log('Could not load user preferences (user may not be logged in)')
  }
}
</script>

<style scoped>
.search-input::placeholder {
  text-align: center;
}

.search-input:focus::placeholder {
  opacity: 0;
}
.seed-selection {
  max-width: 100%;
}
</style>
