<template>
  <div class="seed-selection mb-8">
    <!-- Search Container -->
    <div class="search-container mb-6">
      <div class="rounded-lg p-4">
        <div class="max-w-4xl mx-auto">
          <div class="relative" ref="searchContainer">
            <!-- Search Icon -->
            <div class="absolute inset-y-0 left-0 flex items-center pointer-events-none z-20 pl-4">
              <Icon :icon="faSearch" class="w-5 h-5 text-white/40" />
            </div>
            
            <input
              v-model="searchQuery"
              type="text"
              class="w-full py-3 pl-12 pr-12 bg-white/10 rounded-lg border border-white/20 focus:border-k-accent text-white text-lg"
              placeholder="Search for artists, tracks, albums..."
              @input="onSearchInput"
            />
            
            
            <!-- Search Dropdown -->
            <div 
              v-if="searchResults.length > 0" 
              class="absolute z-50 w-full bg-k-bg-secondary border border-k-border rounded-lg mt-1 shadow-xl"
            >
              <div class="max-h-80 rounded-lg overflow-hidden overflow-y-auto">
                <div v-for="track in filteredSearchResults.slice(0, 10)" :key="`suggestion-${track.id}`">
                  <div 
                    @click="selectSeedTrack(track)"
                    class="flex items-center justify-between px-4 py-3 hover:bg-k-bg-tertiary cursor-pointer transition-colors group border-b border-k-border/30 last:border-b-0"
                    :class="{
                      'bg-k-accent/10': selectedTrack && selectedTrack.id === track.id
                    }"
                  >
                    <!-- Track Info -->
                    <div class="flex-1 min-w-0">
                      <div class="font-medium text-k-text-primary group-hover:text-k-accent transition-colors truncate">
                        {{ formatArtists(track) }} - {{ track.name }}
                      </div>
                    </div>
                    
                    <!-- Duration Badge -->
                    <div class="bg-k-bg-primary/30 px-2 py-1 rounded text-k-text-tertiary text-xs font-mono ml-3 flex-shrink-0">
                      {{ formatDuration(track.duration_ms) }}
                    </div>
                  </div>
                </div>
                
                <div v-if="filteredSearchResults.length > 10" class="px-4 py-3 text-center text-k-text-tertiary text-sm border-t border-k-border bg-k-bg-tertiary/20">
                  <Icon :icon="faMusic" class="mr-1 opacity-50" />
                  {{ filteredSearchResults.length - 10 }} more tracks found
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Selected Seed Track Display - Compact -->
    <div v-if="selectedTrack" class="selected-seed mb-4 relative z-20">
      <div class="text-sm font-medium mb-2" style="color: #1e6880;">Seed Track:</div>
      <div class="bg-k-bg-secondary/50 border border-k-border rounded-lg px-3 py-2">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2 flex-1 min-w-0">
            <Icon :icon="faCheck" class="w-4 h-4 text-k-accent flex-shrink-0" />
            <span class="text-k-text-primary font-medium truncate">{{ formatArtists(selectedTrack) }} - {{ selectedTrack.name }}</span>
          </div>
          <button
            @click="clearSeedTrack"
            class="p-1 hover:bg-red-600/20 text-k-text-tertiary hover:text-red-400 rounded transition-colors flex-shrink-0 ml-2"
            title="Clear seed track"
          >
            <Icon :icon="faTimes" class="w-4 h-4" />
          </button>
        </div>
      </div>
    </div>



    <!-- Error State -->
    <div v-if="searchError" class="bg-red-500/20 border border-red-500/40 rounded-lg p-4 max-w-2xl mx-auto">
      <div class="flex items-start gap-3">
        <Icon :icon="faExclamationTriangle" class="text-red-400 mt-0.5" />
        <div>
          <h4 class="font-medium text-red-200 mb-1">Search Error</h4>
          <p class="text-red-200">{{ searchError }}</p>
        </div>
        <button
          @click="searchError = ''"
          class="ml-auto text-red-400 hover:text-red-300"
        >
          <Icon :icon="faTimes" class="w-4 h-4" />
        </button>
      </div>
    </div>

    <!-- Instructions -->
    <div v-if="!selectedTrack && searchResults.length === 0 && !searchQuery.trim() && !isSearching" class="text-center py-12">
      <Icon :icon="faMusic" class="text-6xl text-white/20 mb-6" />
      <h3 class="text-xl font-medium text-white mb-4">Find Your Seed Track</h3>
      <p class="text-white/60 text-lg mb-6">
        Search for a song to use as the starting point for music discovery
      </p>
      <!-- <p class="text-white/40 text-sm">
        The algorithm will find similar tracks based on your selected parameters
      </p> -->
    </div>

  </div>
</template>

<script setup lang="ts">
import { faSearch, faExclamationTriangle, faHeart, faBan, faMusic, faPlay, faTimes, faCheck, faUserPlus, faUserMinus, faRandom } from '@fortawesome/free-solid-svg-icons'
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { http } from '@/services/http'

interface Track {
  id: string
  name: string
  artist: string
  album: string
  duration_ms?: number
  external_url?: string
  preview_url?: string
  image?: string
  uri?: string
  artists?: Array<{
    id: string
    name: string
  }>
}

// Props
interface Props {
  selectedTrack?: Track | null
  hasRecommendations?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  selectedTrack: null,
  hasRecommendations: false
})

// Emits
const emit = defineEmits<{
  'update:selectedTrack': [track: Track | null]
  'track-selected': [track: Track]
  'related-tracks': [track: Track]
  'search-results-changed': [hasResults: boolean]
  'clear-recommendations': []
}>()

// State
const searchQuery = ref('')
const searchResults = ref<Track[]>([])
const searchError = ref('')
const currentPage = ref(1)
const isSearching = ref(false)
const expandedTrackId = ref<string | null>(null)
const searchContainer = ref<HTMLElement | null>(null)
let searchTimeout: NodeJS.Timeout | null = null

// Music preferences state
const savedTracks = ref<Set<string>>(new Set())
const blacklistedTracks = ref<Set<string>>(new Set())
const savedArtists = ref<Set<string>>(new Set())
const blacklistedArtists = ref<Set<string>>(new Set())
const processingTrack = ref<string | null>(null)


// Computed - For seed track selection, show ALL tracks (including blacklisted)
// Blacklisted artists should appear in search so they can be selected as seed tracks
// But they won't appear in the recommendation results
const filteredSearchResults = computed(() => {
  // For seed track selection, show all search results without filtering
  // Only filter out tracks that are completely invalid/broken
  return searchResults.value.filter(track => {
    return track && track.name && track.artist // Basic validation only
  })
})

const displayedTracks = computed(() => {
  const start = (currentPage.value - 1) * 20
  const end = start + 20
  return filteredSearchResults.value.slice(start, end)
})

// Helper functions
const getTrackKey = (track: Track): string => {
  return `${track.artist}-${track.name}`.toLowerCase().replace(/[^a-z0-9]/g, '-')
}

const isTrackSaved = (track: Track): boolean => {
  return savedTracks.value.has(getTrackKey(track))
}

const isTrackBlacklisted = (track: Track): boolean => {
  return blacklistedTracks.value.has(getTrackKey(track))
}

const isArtistSaved = (track: Track): boolean => {
  return savedArtists.value.has(track.artist.toLowerCase())
}

const isArtistBlacklisted = (track: Track): boolean => {
  return blacklistedArtists.value.has(track.artist.toLowerCase())
}

const formatDuration = (ms?: number): string => {
  if (!ms) return '0:00'
  const minutes = Math.floor(ms / 60000)
  const seconds = Math.floor((ms % 60000) / 1000)
  return `${minutes}:${seconds.toString().padStart(2, '0')}`
}

const formatArtists = (track: Track): string => {
  // If track has multiple artists array, use that; otherwise fall back to single artist string
  if (track.artists && track.artists.length > 0) {
    return track.artists.map(artist => artist.name).join(', ')
  }
  return track.artist
}

// Auto-search functionality with debouncing
const onSearchInput = () => {
  // Clear existing timeout
  if (searchTimeout) {
    clearTimeout(searchTimeout)
  }

  // Clear results immediately if query is empty
  if (!searchQuery.value.trim()) {
    searchResults.value = []
    searchError.value = ''
    return
  }

  // Search works normally - recommendations will be hidden when search results show

  // Set new timeout for search
  searchTimeout = setTimeout(() => {
    searchTracks()
  }, 500) // Wait 500ms after user stops typing
}

// Search functionality
const searchTracks = async () => {
  if (!searchQuery.value.trim()) return

  console.log('üîç [FRONTEND] Starting search for:', searchQuery.value.trim())
  
  isSearching.value = true
  searchError.value = ''
  searchResults.value = []
  currentPage.value = 1

  try {
    console.log('üîç [FRONTEND] Making API call to music-discovery/search-seed')
    
    // Use the updated search-seed endpoint with Spotify fallback
    const response = await http.post('music-discovery/search-seed', {
      query: searchQuery.value.trim(),
      limit: 100
    })
    
    console.log('üîç [FRONTEND] API Response received:', {
      success: response.success,
      dataLength: response.data?.length,
      error: response.error
    })
    
    if (response.success && response.data && Array.isArray(response.data)) {
      searchResults.value = response.data
      console.log(`üîç [FRONTEND] Found ${response.data.length} tracks from search`)
      console.log('üîç [FRONTEND] Sample track data:', response.data[0]) // Debug the structure
      console.log('üîç [FRONTEND] All tracks:', response.data.map(t => `${t.artist} - ${t.name}`))
    } else {
      throw new Error(response.error || 'Invalid response format from backend')
    }
  } catch (err: any) {
    console.error('üîç [FRONTEND] Search failed:', err)
    searchError.value = err.message || 'Failed to search tracks. Please try again.'
    searchResults.value = []
  } finally {
    isSearching.value = false
  }
}

// Seed track management
const selectSeedTrack = (track: Track) => {
  // Clear previous recommendations when selecting a new seed track
  emit('clear-recommendations')
  emit('update:selectedTrack', track)
  emit('track-selected', track)
  // Clear search results after selection
  searchResults.value = []
  searchQuery.value = ''
  // Always get related tracks for the newly selected seed track
  getRelatedTracks(track)
}

const clearSeedTrack = () => {
  emit('update:selectedTrack', null)
  // Clear search results to return to initial state
  searchResults.value = []
  searchQuery.value = ''
  // Emit event to clear recommendations
  emit('clear-recommendations')
}

const getRelatedTracks = (track: Track) => {
  // Clear search results when getting related tracks to prevent overlay
  searchResults.value = []
  searchQuery.value = ''
  
  // Just emit the related tracks request without setting as seed track
  // (the track should already be set as seed track if called from selectSeedTrack)
  emit('related-tracks', track)
}


// Music preferences
const saveTrack = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artist = track.artist
    const title = track.name

    if (isTrackSaved(track)) {
      // Remove from saved (using DELETE request)
      const response = await http.delete('music-preferences/saved-track', {
        data: {
          isrc: track.id,
          track_name: title,
          artist_name: artist
        }
      })

      if (response.success) {
        savedTracks.value.delete(trackKey)
        console.log('Track unsaved successfully')
      } else {
        throw new Error(response.error || 'Failed to unsave track')
      }
    } else {
      // Save track
      const response = await http.post('music-preferences/save-track', {
        isrc: track.id,
        track_name: title,
        artist_name: artist,
        duration: Math.floor((track.duration_ms || 0) / 1000)
      })

      if (response.success) {
        savedTracks.value.add(trackKey)
        console.log('Track saved successfully')
      } else {
        throw new Error(response.error || 'Failed to save track')
      }
    }
  } catch (error: any) {
    console.error('Failed to save track:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to save tracks'
    } else {
      searchError.value = `Failed to save track: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}

const toggleBlacklistTrack = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artist = track.artist
    const title = track.name

    if (isTrackBlacklisted(track)) {
      // Unblock track
      const response = await http.delete('music-preferences/blacklist-track', {
        data: {
          isrc: track.id,
          track_name: title,
          artist_name: artist
        }
      })

      if (response.success) {
        blacklistedTracks.value.delete(trackKey)
        console.log('Track unblocked successfully')
      } else {
        throw new Error(response.error || 'Failed to unblock track')
      }
    } else {
      // Block track
      const response = await http.post('music-preferences/blacklist-track', {
        isrc: track.id,
        track_name: title,
        artist_name: artist
      })

      if (response.success) {
        blacklistedTracks.value.add(trackKey)
        console.log('Track blacklisted successfully')
      } else {
        throw new Error(response.error || 'Failed to blacklist track')
      }
    }
  } catch (error: any) {
    console.error('Failed to toggle blacklist:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to manage track preferences'
    } else {
      searchError.value = `Failed to toggle blacklist: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}

// Artist preferences
const saveArtist = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artistName = track.artist
    const artistKey = artistName.toLowerCase()

    if (isArtistSaved(track)) {
      // Remove from saved artists
      const response = await http.delete('music-preferences/saved-artist', {
        data: {
          spotify_artist_id: track.id, // Use track ID as fallback if no artist ID
          artist_name: artistName
        }
      })

      if (response.success) {
        savedArtists.value.delete(artistKey)
        console.log('Artist unsaved successfully')
      } else {
        throw new Error(response.error || 'Failed to unsave artist')
      }
    } else {
      // Save artist
      const response = await http.post('music-preferences/save-artist', {
        spotify_artist_id: track.id, // Use track ID as fallback if no artist ID  
        artist_name: artistName
      })

      if (response.success) {
        savedArtists.value.add(artistKey)
        console.log('Artist saved successfully')
      } else {
        throw new Error(response.error || 'Failed to save artist')
      }
    }
  } catch (error: any) {
    console.error('Failed to save artist:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to save artists'
    } else {
      searchError.value = `Failed to save artist: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}

const blacklistArtist = async (track: Track) => {
  const trackKey = getTrackKey(track)
  processingTrack.value = trackKey

  try {
    const artistName = track.artist
    const artistKey = artistName.toLowerCase()

    if (isArtistBlacklisted(track)) {
      // Remove from blacklisted artists
      const response = await http.delete('music-preferences/blacklist-artist', {
        data: {
          spotify_artist_id: track.id, // Use track ID as fallback if no artist ID
          artist_name: artistName
        }
      })

      if (response.success) {
        blacklistedArtists.value.delete(artistKey)
        console.log('Artist unblacklisted successfully')
      } else {
        throw new Error(response.error || 'Failed to unblacklist artist')
      }
    } else {
      // Blacklist artist
      const response = await http.post('music-preferences/blacklist-artist', {
        spotify_artist_id: track.id, // Use track ID as fallback if no artist ID
        artist_name: artistName
      })

      if (response.success) {
        blacklistedArtists.value.add(artistKey)
        console.log('Artist blacklisted successfully')
      } else {
        throw new Error(response.error || 'Failed to blacklist artist')
      }
    }
  } catch (error: any) {
    console.error('Failed to blacklist artist:', error)
    if (error.response?.status === 401 || error.message.includes('Unauthenticated') || error.message.includes('Authentication required')) {
      searchError.value = 'Please log in to manage artist preferences'
    } else {
      searchError.value = `Failed to blacklist artist: ${error.response?.data?.error || error.message}`
    }
  } finally {
    processingTrack.value = null
  }
}


// Pagination
const nextPage = () => {
  if (currentPage.value * 20 < filteredSearchResults.value.length) {
    currentPage.value++
  }
}

const previousPage = () => {
  if (currentPage.value > 1) {
    currentPage.value--
  }
}

// Watch search results and emit changes to parent
watch(searchResults, (newResults) => {
  emit('search-results-changed', newResults.length > 0)
})

// Watch for recommendations to clear search results and prevent overlay
watch(() => props.hasRecommendations, (hasRecommendations, wasRecommendations) => {
  // Only clear when recommendations first appear (transition from false to true)
  if (hasRecommendations && !wasRecommendations) {
    // Clear search results when recommendations first appear to prevent overlay
    searchResults.value = []
    searchQuery.value = ''
  }
})

// Click outside handler to close dropdown
const handleClickOutside = (event: MouseEvent) => {
  if (searchContainer.value && !searchContainer.value.contains(event.target as Node)) {
    searchResults.value = []
  }
}

// Load saved preferences on mount
onMounted(async () => {
  await loadUserPreferences()
  document.addEventListener('click', handleClickOutside)
})

// Clean up event listener
onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside)
})

// Load user's saved tracks and blacklisted items
const loadUserPreferences = async () => {
  try {
    // Load blacklisted tracks
    const blacklistedTracksResponse = await http.get('music-preferences/blacklisted-tracks')
    if (blacklistedTracksResponse.success && blacklistedTracksResponse.data) {
      blacklistedTracksResponse.data.forEach((track: any) => {
        const trackKey = `${track.artist_name}-${track.track_name}`.toLowerCase().replace(/[^a-z0-9]/g, '-')
        blacklistedTracks.value.add(trackKey)
      })
      console.log(`Loaded ${blacklistedTracks.value.size} blacklisted tracks`)
    }

    // Load saved tracks  
    const savedTracksResponse = await http.get('music-preferences/saved-tracks')
    if (savedTracksResponse.success && savedTracksResponse.data) {
      savedTracksResponse.data.forEach((track: any) => {
        const trackKey = `${track.artist_name}-${track.track_name}`.toLowerCase().replace(/[^a-z0-9]/g, '-')
        savedTracks.value.add(trackKey)
      })
      console.log(`Loaded ${savedTracks.value.size} saved tracks`)
    }

    // Load blacklisted artists
    const blacklistedArtistsResponse = await http.get('music-preferences/blacklisted-artists')
    if (blacklistedArtistsResponse.success && blacklistedArtistsResponse.data) {
      blacklistedArtistsResponse.data.forEach((artist: any) => {
        blacklistedArtists.value.add(artist.artist_name.toLowerCase())
      })
      console.log(`Loaded ${blacklistedArtists.value.size} blacklisted artists`)
    }

    // Load saved artists
    const savedArtistsResponse = await http.get('music-preferences/saved-artists')
    if (savedArtistsResponse.success && savedArtistsResponse.data) {
      savedArtistsResponse.data.forEach((artist: any) => {
        savedArtists.value.add(artist.artist_name.toLowerCase())
      })
      console.log(`Loaded ${savedArtists.value.size} saved artists`)
    }

  } catch (error) {
    console.log('Could not load user preferences (user may not be logged in)')
  }
}
</script>

<style scoped>
.seed-selection {
  max-width: 100%;
}

</style>